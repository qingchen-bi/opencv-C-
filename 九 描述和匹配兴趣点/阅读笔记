1.局部模板匹配
描述子：描述了一个关键点和他的领域
通过特征点匹配， 可以将一幅图像的点集和另一幅图像（或一批图
像） 的点集关联起来。 如果两个点集对应着现实中的同一个场景元素
（或物体点） ， 它们就应该匹配。
要判断两个关键点的相似度， 仅凭单个像素显然是不够的。 因此需要
在匹配过程中考虑每个关键点周围的图像块。 如果两个图像块对应
着同一个场景元素， 那么它们的像素值应该会比较相似。 本节介绍的
方案是对图像块中的像素进行逐个比较。 这可能是最简单的特征点匹
配方法了， 但是我们将会看到， 这种方法并不是最可靠的。 不过在某
些情况下， 它也能得到不错的结果。
最常见的图像块是边长为奇数的正方形， 关键点位置就是正方形的中
心。 可通过比较块内像素的强度值， 来衡量两个正方形图像块的相似
度。 常见的方案是采用简单的差的平方和（Sum of Squared
Differences， SSD） 算法。 
找到一个可能的匹配项后， 用一
个cv::DMatch对象来表示。 该对象存储了两个被匹配关键点的序号
和相似度。
这里我们用一个简单的标准来比较图像块， 即指定CV_TM_SQDIFF
标志， 逐个像素地计算差值的平方和。 在比较图像I1的像素(x, y )和I2
的像素（x', y'） 时， 用下面的公式衡量相似度：

这些(i, j )点的累加值， 就是以每个点为中心的整个正方形模板的偏移
值。 如果两个图像块比较相似， 它们的相邻像素之间的差距就比较
小， 因此累加值最小的块就是最匹配的图像块。 该功能通过匹配函数
的主循环实现， 即针对一个图像的每个关键点， 在另一个图像中找出
差值平方和最小的关键点。 也可以设置一个阈值， 排除掉差值平方和
超过该阈值的匹配项。 

用CV_TM_CCORR标志） ：
如果两个图像块非常相似， 这个值将达到最大。
识别出的匹配项存储在cv::DMatch类型的向量中




9.3描述局部强度值模式
用特征描述子（N维向量）来描述兴趣点的邻域
OpenCV 2提供了一个通用的接口， 用于批量计算关键点的描述子。
该接口名为cv::DescriptorExtractor
大多数基于特征的方法都包含一个检测器和一个描述子组件

步骤：
构建相应检测器对象；检测关键点；从关键点提取描述子
利用两幅的描述子向量进行关键点匹配

1. 交叉检查匹配项
有一种简单的方法可以验证得到的匹配项， 即重新进行同一个匹配过
程。 第二次匹配时， 将第二幅图像的每个关键点逐个与第一幅图像的
全部关键点进行比较。 只有在两个方向都匹配了同一对关键点（即两
个关键点互为最佳匹配） ， 才认为是一个有效的匹配项

2. 比率检验法
我们已经注意到， 正是场景物体中的重复元素导致了匹配结果不可
靠， 这是因为在匹配视觉上， 类似的结构时会产生歧义。 这种情况
下， 一个关键点会与多个关键点很好地匹配。 因为选中错误匹配的可
能性很大， 所以比较可取的做法是排除此类匹配。
要使用这种策略， 需要为每个关键点找到两个最佳的匹配项。 
下一步是排除与第二个匹配项非常接近的全部最佳匹配项。 

3. 匹配差值的阈值化
还有一种更加简单的策略， 就是把描述子之间的差值太大的匹配项排
除。 实现此功能的是cv::DescriptorMatcher类的
radiusMatch方法：



9.4 用二值特征描述关键点
为了减少内存使
用， 降低计算量， 最近人们引入了二值描述子的概念
本节介绍
其中的几种二值描述子。 重点讲解ORB和BRISK描述子，
ORB等二值描述子的用法与SURF、 SIFT等没有什么区别
步骤：
// 定义关键点向量
std::vector<cv::KeyPoint> keypoints1, keypoints2;
// 构造ORB特征检测器对象
cv::Ptr<cv::FeatureDetector> detector =
new cv::ORB(100); // 检测大约100个ORB特征点
// 检测ORB特征
detector->detect(image1,keypoints1);
detector->detect(image2,keypoints2);
// ORB包含了检测器和描述子提取器
cv::Ptr<cv::DescriptorExtractor> descriptor = detector;
// 提取描述子
cv::Mat descriptors1, descriptors2;
descriptor->compute(image1,keypoints1,descriptors1);
descriptor->compute(image2,keypoints2,descriptors2);
// 构造匹配器
cv::BFMatcher matcher(
cv::NORM_HAMMING); // 对二值描述子， 永远使用hamming规范
// 匹配两个图像描述子
std::vector<cv::DMatch> matches;
matcher.match(descriptors1,descriptors2, matches);
原理：
ORB算法在多个尺度下检测特征点， 这些特征点含有方向。 基于这些
特征点， ORB描述子通过简单比较强度值， 提取出每个关键点的表
征。 实际上ORB就是在BRIEF描述子的基础上构建的（前面介绍过
BRIEF描述子） 。 然后在关键点周围的邻域内随机选取一对像素点，
创建一个二值描述子。 比较这两个像素点的强度值， 如果第一个点的
强度值较大， 就把对应描述子的位（bit） 设为1， 否则就设为0。 对一
批随机像素点对进行上述处理， 就产生一个由若干位（bit） 组成的描
述子
根据实验验证， ORB选出了变
化幅值较高、 相关性极小的256对像素点


