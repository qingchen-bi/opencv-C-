第一章：
opencv：开源程序库
计算机视觉：
头文件：core.hpp;highgui.hpp; 
常用函数：imread(); imshow(); nameWindows(); imshow(); imwrite(); waitKey(0); 

深入了解CV：：Mat
两个组成部分：头部（包含大小 通道数量 数据类型）数据块（存储像素值）
行列通道可以用：cols rows channels访问
实际上除了特殊说明不会复制Mat类数据块，只是复制头部信息，这样存在多个头部指向同一个数据快

imagel.create();//重新分配一个新的

输入输出数组：cv::InputArray; output   //代理类
避免同一个方法或函数因为使用了不同
类型的输入参数而出现多个不同的版本 

定义兴趣区：ROI，用创建Mat实例就可以
Mat ROI=imageROI（image，cv::Rect(
							//ROI坐标
							//ROI大小
								)）
copyTo（imageROI）//插入标志

掩码：通过掩码可以选择性的对于某些像素进行操作，只有掩码不为0才会操作起作用




第二章：操作像素

访问像素：image.at<cv::Vec3b>(I,j)[0];
在调用时必须指定图像元素的类型， 

用指针扫描图像：image.ptr<uchar>(j)[i]
			image.ptr<uchar>(j) //第j行的地址
			
用迭代器扫描图像
    cv::Mat_<cv::Vec3b>::iterator it=
            image.begin<cv::Vec3b>();//获得在初始位置的迭代器
    cv::Mat_<cv::Vec3b>::iterator itend=
            image.end<Vec3b>();//获得结束位置


cv::getTickCount()， 该函数返回从最近一次电脑开机到
当前的时钟周期数。 因为我们希望得到以秒为单位的代码运行时间，
所以要使用另一个方法， 即cv::getTickFrequency()， 这个方
法返回每秒的时钟周期数。 为了获得某个函数（或代码段） 的运行时
间， 通常需使用这样的程序模板： 

扫描图像的相邻像素
锐化图像：
在图像处理领域有一个众所周知的
结论： 如果从图像中减去拉普拉斯算子部分， 图像的边缘就会放大，
因而图像会变得更加尖锐。 

为了访问在上一行和下一行的相邻像素， 只需定义额外的指针， 并与
当前行的指针一起递增， 然后就可以在扫描循环内访问上下行的指针
了。 

两个图像相加
这里我们把两个图像相加， 用于创建特效图或覆盖图像中的信息。 我
们可以使用cv::add函数来实现相加功能。 现在我们想得到加权
和， 因此使用更精确的cv::addWeighted函数： 

分割图像通道
有时我们需要分别处理图像中的不同通道， 例如只对图像中的一个通
道执行某个操作。 这当然可以通过图像扫描循环实现， 但也可以使
用cv::split函数， 将图像的三个通道分别复制到三个不同的
cv::Mat实例中。 假设我们要把一个雨景图只加到蓝色通道中， 可
以这样实现： 

图像重映射：
remap（）
输入的参数由映射参数：
表示：把每个像素的位置重新映射到新的位置。



